// этот файл содержит примеры использования моей библиотеки для отображения математических графиков в графическом окне на базе SFML

#include "graph.hpp"
#define _USE_MATH_DEFINES // чтобы можно было использовать числор пи M_PI

int main(void) {
    Graph g("sin(x) and cos(x)"); // создание экземпляра класса Graph (окна с графикми), с заголовком "sin(x) and cos(x)"

    // ====== пример 1. нарисуем графики синуса и косинуса ======
    std::vector<double> X, Y_sin, Y_cos; // массивы, в которые будут записаны данные для отображения на графиках
    // X - массив с точками по оси X (точками сетки), он будет общий для синуса и косинуса
    // Y_sin - массив со значениями синуса в точках сетки
    // Y_cos - массив со значениями косинуса в точках сетки
    for(double x = -M_PI; x < M_PI; x += 0.01) { // цикл по сетке от -пи до пи с шагом 0.01
        X.push_back(x); // добавляем в массив X точку сетки
        Y_sin.push_back(sin(x)); // добавляем в массив Y_sin значение синуса
        Y_cos.push_back(cos(x)); // добавляем в массив Y_cos значение косинуса
    }
    g.graph(X, Y_sin, {255, 0, 0}); // добавляем в окно график синуса, цвет делаем красным
    g.graph(X, Y_cos, {0, 0, 255}); // добавляем в окно график косинуса, цвет делаем синим
    g.show(-1); // запускаем цикл обработки окна, аргумент означает время работы цикла в секундах
    // -1 значит обрабатывать бесконечно, пока пользователь не закроет окно
    
    // ====== пример 2. удалим график косинуса и вместо этого нарисуем окружность радиуса 1.5 ======
    g.pop(); // удаляем последний добавленный график (т. е. график косинуса)
    std::vector<double> X_circle, Y_circle; // массивы с координатами точек на окружности
    for(double phi = 0; phi < 2 * M_PI; phi += 0.01) { // цикл угла phi по сетке от 0 до 2*пи с шагом 0.01
        // используем параметризацию окружности (r*cos(phi), r*sin(phi))
        X_circle.push_back(1.5 * cos(phi));
        Y_circle.push_back(1.5 * sin(phi));
    }
    g.graph(X_circle, Y_circle, {0, 255, 0}); // рисуем зелёный круг
    g.label = "sin(x) and x^2 + y^2 = 1.5^2"; // изменяем заголовок окна
    g.reset_placement(true); // сбрасываем положение графиков в окне на автоматически выбранное по умолчанию (чтобы все графики влезали)
    // аргумент true значит, что масштаб по осям x и y будет одинаковым (чтобы круг не был растянут)
    // сброс всё равно происходит автоматически после закрытия окна, но запуск вручную позволяет сделать одинаковый масштаб по осям
    g.show(-1); // запускаем цикл обработки окна, пока пользователь не закроет окно

    // ====== пример 3. нарисуем логарифмическую спираль из точек, вращающуюся внутри окружности из точек ======
    g.clear(); // удаляем все старые графики
    std::vector<double> X_circle_points, Y_circle_points; // массивы с координатами точек на окружности
    for(double phi = 0; phi < 2 * M_PI; phi += M_PI / 36) { // цикл угла phi по сетке от 0 до 2*пи с шагом пи/36
        // используем параметризацию окружности (r*cos(phi), r*sin(phi))
        X_circle_points.push_back(cos(phi));
        Y_circle_points.push_back(sin(phi));
    }
    g.graph_points(X_circle_points, Y_circle_points); // добавляем точечный график круга цвета по умолчению (белого) и радиуса по умолчанию (5 пикс.)
    g.reset_placement(true); // сбрасываем положение графиков с одинаковым масштабом по осям
    g.label = "rotating spiral"; // изменяем заголовок окна
    g.fps = 40; // утанавливаем частоту кадров 40;
    double t = 0; // примерное время в секундах
    do {
        if(t) // если это не первый проход цикла
            g.pop_points(); // то удаляем последний точечный график (т. е. спираль)
        std::vector<double> X_spiral, Y_spiral; // массивы с координатами точек на спирали
        for(double phi = 0; phi < 100; phi += M_PI / 36) { // цикл угла phi по сетке от 0 до 100 с шагом пи/36
            // используем параметризацию спирали (a^phi*cos(phi+t), a^phi*sin(phi+t)) с поворотом на t
            X_spiral.push_back(std::pow(0.75, phi) * cos(phi + t));
            Y_spiral.push_back(std::pow(0.75, phi) * sin(phi + t));
        }
        g.graph_points(X_spiral, Y_spiral, {255, 0, 0}, 3); // рисуем спираль точками красного цвета радиука 3
        t += 1.0 / 40; // прибавляем время, затраченное на один кадр при частоте кадров 40
    } while(g.show(0)); // обрабатываем окно в течении одного кадра и завершаем цикл, если окно было закрыто пользователем

    // ====== пример 4. нарисуем анимацию с последовательно появляющимися графиками x^n ======
    g.clear(); // очистка
    g.label = "x^n"; // изменяем заголовок окна
    g.background = sf::Color(255, 255, 255); // для разнообразия сделаем белый фон
    g.axes_color = sf::Color(0, 0, 0); // и чёрные оси и надписи
    g.reset_placement(-1.2, 1.2, -1.2, 1.2, true); // расположим систему координат так, чтобы квадрат [-1.2, 1.2]x[-1.2, 1.2] вмещался на экран
    // последний аргумент true значит, что масштабы по осям X и Y будут совпадать
    int n = -1; // степень x^n, до которой мы рисуем графики
    // -1 это чтобы после первого инкремента n стало 0
    do {
        n ++;
        if(n > 20) {
            n = 0;
            g.clear();
        } // если n превзошло 10, сбрасываем n и убираем все графики
        std::vector<double> X, Y; // массивы с координатами точек на графике x^n
        for(double x = -4; x < 4; x += 0.01) { // цикл по сетке от -4 до 4 с шагом 0.01
            X.push_back(x); // добавляем в массив X точку сетки
            Y.push_back(std::pow(x, n)); // добавляем в массив Y значение x^n
        }
        g.graph(X, Y, {(sf::Uint8)(n * 8), (sf::Uint8)(160 - n * 8), 0}); // цвет зависит от n, изменяясь от зелёного к красному по мере возрастания n
    } while(g.show(0.5)); // обрабатываем окно в течении 0.5 секунды и завершаем цикл, если окно было закрыто пользователем

    // ====== пример 5. В точности то же, что четвёртый пример, но на логарифмической шкале ======
    // функции вида y = x^n должны на логарифмической шкале отображаться как линейные, т. к. log(y) = n*log(x)
    g.clear(); // очистка
    g.set_logscale_x(true); // установка логарифмической шкалы по оси X во включенное состояние (true)
    g.set_logscale_y(true); // установка логарифмической шкалы по оси Y во включенное состояние (true)
    g.reset_placement(0.1, 4, 0.01, 100); // расположим систему координат так, чтобы квадрат [0.1, 4]x[0.01, 1000] вмещался на экран
    // заметьте, что отрицательные координаты на логарифмической шкале отображаться не могут в принципе
    n = -1; // степень x^n, до которой мы рисуем графики
    // -1 это чтобы после первого инкремента n стало 0
    do {
        n ++;
        if(n > 20) {
            n = 0;
            g.clear();
        } // если n превзошло 10, сбрасываем n и убираем все графики
        std::vector<double> X, Y; // массивы с координатами точек на графике x^n
        for(double x = -4; x < 4; x += 0.01) { // цикл по сетке от -4 до 4 с шагом 0.01
            X.push_back(x); // добавляем в массив X точку сетки
            Y.push_back(std::pow(x, n)); // добавляем в массив Y значение x^n
        }
        g.graph(X, Y, {(sf::Uint8)(n * 8), (sf::Uint8)(160 - n * 8), 0}); // цвет зависит от n, изменяясь от зелёного к красному по мере возрастания n
    } while(g.show(0.5)); // обрабатываем окно в течении 0.5 секунды и завершаем цикл, если окно было закрыто пользователем

    return 0;
}
